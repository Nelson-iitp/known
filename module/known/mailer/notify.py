#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
__doc__=r"""
:py:mod:`known/mailer/notify.py`
"""
#=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

import os, platform
from .mail import Mail
__all__=['AutoNotify']

class AutoNotify:
    r""" Auto Notification Module : Uses a Mail object to send a set of pre-sepecified emails along with attachements

    :param login_path: (str) path for login credential json file (```gmail.json``` by default)
    :param style_info: (str) the style to choose from ```MY_STYLES```
    :param config_info: (str) the style to choose from ```MY_CONFIGS```
    :param attach_info: (str) the style to choose from ```MY_ATTACHED```

    .. warning:: This requires saving your login credentials on machine in pain json format. 
        You should enable 2-factor-auth in gmail and generate an app-password instead of using your gmail password.
        Visit (https://myaccount.google.com/apppasswords) to generate app-password
    """

    @staticmethod
    def global_alias(): return f'{os.getlogin()} @ {platform.node()}:{platform.system()}.{platform.release()}'

    def __init__(self, login_path='gmail', style_info=None, config_info=None, attach_info=None) -> None:
        self.alias = __class__.global_alias()
        self.username, self.password = __class__.load_login(login_path)
        self.build_styles()
        self.build_configs()
        self.build_attached()

        if style_info is not None: self.load_styles(style_info)
        if config_info is not None: self.load_configs(config_info)
        if attach_info is not None: self.load_attached(attach_info)

    @staticmethod
    def json_loader(path, keys, adderF):
        d = Mail.load_json(path)
        for k,v in d.items(): 
            t = [kk in v for kk in keys]
            if not (False in t): adderF(k, **{s:v[s] for s in keys} )

    def build_styles(self):
        self.MY_STYLES = {

        'default' : dict(

            # subject_fix: 2-tuple (subject-prefix, subject-postfix), 
            # enclose subject line within these strings
            # NOTE: actual subject will be provided while sending mail (can be changed for each email)
            subject_fix = (f'[Auto.Notify]::[', ']'), 
            
            # content_seperator: seperates strings in the email content-lines list (which is a list of strings in Mail class)
            # this works like print's end_with argument
            content_seperator= '\n',

            # signature : will be added at the end of all content
            signature = f"\nThis e-mail was auto-generated by {self.alias}.\n",
            ),

        }
    def add_style(self, name, subject_fix, content_seperator, signature):
        self.MY_STYLES[name] = dict(
            subject_fix = subject_fix, 
            content_seperator = content_seperator,
            signature = signature,)
    def load_styles(self, path): return __class__.json_loader(path, ['subject_fix', 'content_seperator', 'signature'], self.add_style)


    def build_configs(self):
        self.MY_CONFIGS = {
        'default' : dict(
            # recipents: list of recipent e-mail (to, cc, bcc)
            rx = [self.username,],               #<---- TO Rx
            cc = [],                             #<---- CC
            bcc = [],                             #<---- BCC
        ),}
    def add_config(self, name, rx, cc, bcc): self.MY_CONFIGS[name] = dict(rx = rx,cc = cc, bcc = bcc)
    def load_configs(self, path): return __class__.json_loader(path, ['rx', 'cc', 'bcc'] , self.add_config)

    def build_attached(self):
        # attached: a list of files to be attached in the email, each item in attached list is a 2-Tuple 
        # iterate using: for (attach_type, attach_files) in attached: 
        # attach_files(Tuple) contains the file names to be attached, it must be a tuple even if there is a single file to attach
        # attach_type(str) is the name of zip file, if not provided (left blank), will not zip and instead attach files individually
        
        self.MY_ATTACHED = {
            'default' : dict( 
                attached = [
                    #( '',                    (tuple of paths....) ),
                    #( 'zipfile.zip',         (tuple of paths....) ),
                ],
            ),

        }
    def add_attached(self, name, attached):  self.MY_ATTACHED[name] = dict(attached = attached)
    def load_attached(self, path): return __class__.json_loader(path, ['attached'] , self.add_attached)
    #--------------------------------------------------
    def notify(self, subject='notify', style='default', config='default', attach='default'):
        r""" sends mail notification

        :param subject: subject of the email
        :param style: choose from predefined styles dict
        :param config: choose from predefined configs dict
        :param attach: choose from predefined attach dict
        """
        try:
            my_style = self.MY_STYLES.get(style, self.MY_STYLES['default'])
            my_config = self.MY_CONFIGS.get(config, self.MY_CONFIGS['default'])
            my_attached = self.MY_ATTACHED.get(attach, self.MY_ATTACHED['default'] )
            mailer = Mail(
                username=self.username, 
                password=lambda : self.password, 
                subject_fix=my_style['subject_fix'],
                content_seperator=my_style['content_seperator'],
                signature=my_style['signature'],
                rx=my_config['rx'], cc=my_config['cc'], bcc=my_config['bcc'],
                attached=my_attached
                )
            mailer.send(subject=f'{subject}')
            success=True
        except:
            success=False
        return success
    #--------------------------------------------------

    @staticmethod
    def save_login(username, password, path='gmail'):
        r""" save your login credentials as json """
        if not path.lower().endswith('.json'): path = f'{path}.json'
        return Mail.save_json(path, {'username':username, 'password':password})
    
    @staticmethod
    def load_login(path='gmail'):
        r""" load your login credentials from json """
        if not path.lower().endswith('.json'): path = f'{path}.json'
        d = Mail.load_json(path)
        return d.get('username', ''), d.get('password', '')
    #--------------------------------------------------

